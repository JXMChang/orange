<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        正则表达式
        1.用来处理字符串的规则
         正则只能处理字符串
         他是一个规则：可以验证字符串是否符合某个规则(test),
         也可以把字符串中符合规则的内容捕获到(exec/match...)

         正则表达式由2部分组成
         1.元字符
         2.修饰符
        */
        //举例说明
        let str ="How are you!";
        //学正则是用来制定规则(是否包含数字)
        let reg = /\d+/;
        reg.test(str);//false

        str = "2019-08-12";
        reg.exec(str)//["2019", index: 0, input: "2019-08-12", groups: undefined]

        /*
        编写正则表达式，创建的方式有2种
        1.字面量创建方式(2个斜杠之间抱起来的，都是用来描述规则的元字符)
        let reg1 = /\d+/
        
        2.构造函数模式创建 2个参数： 元字符字符串，修饰符字符串
        let reg2 = new RegExp("\\d+");
         
         1.常用的元字符
         一 量词元字符：设置出现的次数
         * 零到多次；
         + 一到多次
         ？零次或者一次
         {n} 出现n次
         {n,}出现n到多次
         {n,m}出现n到m次

         2.特殊元字符：单个或者组合在一起代表特殊的含义
         \ 转义字符(普通->特殊->普通)
         . 除\n(换行符)以外的任意字符
         ^ 以哪一个元字符作为开始
         $ 以哪一个元字符作为结束
         \n 换行符
         \d 0-9之间的一个数字
         \D 非0-9之间的数字(大写和小写的意思是相反的)
         \w 数字,字母，下划线中的任意一个字符
         \s 一个空白字符(包含空格，制表符，换页符等)
         \t 一个制表符(一个TAB键，四个空格)
         \b 匹配一个单词的边界
         举例说明"zhufeng"=>"z"和"g"是边界
         "pei-xun"=>"p"和"i"是边界 "x"和"n"是边界
         x|y x或者y中的一个字符
         [xyz]x或者y或者z中的一个字符
         [^xy]除了x/y以外的任意字符
         [a-z]指定a-z这个范围中的任意字符 [0-9a-zA-z_]===\w
         [^a-z] 上一个的取反"非"
         () 正则中的分组符号
         (?:)只匹配不捕获
         (?=)正向预查
         (?!)负向预查
         [\u4e00-\u9fa5] vcode编码找出相对应的汉字
        */

        //普通元字符：代表本身含义的
       // /zhufeng/ 这就是匹配的是 "zhufeng"

       //正则表达式常用的修饰符：img*/
       //i=>ignoreCase 忽略单词大小写匹配
       //m=>multiline 可以进行多行匹配
       //g=>global    全局匹配
    //    console.log(/A/.test("lalala"))//false
    //    console.log(/A/i.test("lalala"))//true
    //    //用test来验证"lalala"如果在加i(忽略单词大小写匹配)正则符合规则就是true，不符合规则就返回false

    //     //元字符详细解析
    //     "^ $"
    //     let reg = /^\d/;
    //     console.log(reg.test("zhufeng"))//false
    //     console.log(reg.test("2019zhufeng"))//true
    //     console.log(reg.test("zhufeng2019"))//false

    //     let reg = /\d$/;
    //     console.log(reg.test("zhufeng"))//false
    //     console.log(reg.test("2019zhufeng"))//false
    //     console.log(reg.test("zhufeng2019"))//true

    //     //=>/2个都不加：字符串包含符合规则的内容即可
    //     let reg1 =/\d+/;
    //     //=>^/$俩个都加：字符串中包含字符规则一致的内容
    //     let reg2 = /^\d+$/;

    //     //验证手机号
    //      let reg =/^1\d{10}$/

    //     //.不是小数点，是\n以外的任意字符
    //     let reg =/^2.3$/
    //     console.log(reg.test("2.3"))//true
    //     console.log(reg.test("2@3"))//true
    //     console.log(reg.test("2/3"))//true
    //     console.log(reg.test("2+3"))//true
    //     console.log(reg.test("2%5"))//true
    //     console.log(reg.test("123234"))//false
    //     console.log(reg.test("2233"))//true

    //     //基于转义字符，让其只能代表小数点
    //     reg = /^2\.3$/;
    //     console.log(reg.test("2223"))//true
    //     console.log(reg.test("2@3"))//true
    //     console.log(reg.test("2.3"))//true
    //     console.log(reg.test("4/5"))//true
    //     console.log(reg.test("3%5"))//true
    //     console.log(reg.test("2..3"))//true

        // let str ="\\d";
        // reg = /^\d$/;
        // console.log(reg.test(str))//true
        // reg = /^\\d$/;//特殊字符转化为普通字符
        // console.log(reg.test(str))//true

        "x|y"
        //let reg =/^18|208$/;
        // console.log(/^1|[8-9]|[2-9]|[0-9]|10|[0-9]|20|[0-8]$/.test(reg))
        
        // let str ="13691092607"
        //     //str2=/^1\d{10}$/;
        // console.log(/^1[3-9]\d$/.test(str))

        // let str1 ="2819135299"
        // console.log(/^[1-9]\d{4,10}$/.test(str1))

        //let reg =/^18|89$/;
        // console.log(reg.test("18"));//true
        // console.log(reg.test("28"));//true
        // console.log(reg.test("127"))//true
        // console.log(reg.test("1829"))//true
        // console.log(reg.test("1889")//true
        //console.log(reg.test("189"))//true

        //直接x|y会存在很乱的优先级问题，一般我们写的时候都陪伴这小括号进行分组，因为小括号改变处理优先级
        // reg = /^(18|89)$/;
        // console.log(reg.test("19"))//true
        // console.log(reg.test("18"))//true
        // console.log(reg.test("1819"))//true
        // console.log(reg.test("1894"))//false
        // console.log(reg.test("1899"))//false
        // console.log(reg.test("1289"))//false

        `[]`
        //1.中括号中出现的字符一般都代表本身的含义
        let reg = /^[@+]$/;
        console.log(reg.test("@"))//true
        console.log(reg.test("+"));//true
        console.log(reg.test("@@"))//false
        console.log(reg.test("@+"))//false

        reg = /^[\d]$/;
        console.log(reg.test("d"))//false
        console.log(reg.test("\\"))//false
        console.log(reg.test("9"))//true

        reg =/^[18]$/
        console.log(reg.test("1"))//true
        console.log(reg.test("8"))//true
        console.log(reg.test("18"))//false

        reg = /^[10-29]$/
        console.log(reg.test("1"))//true
        console.log(reg.test("9"))//true
        console.log(reg.test("0"))//true
        console.log(reg.test("2"))//true
        console.log(reg.test("10"))//false

        //验证是否为有效数字，
        //规则分析
        //1.可能出现+-号，也可能不出现[+-]?
        //2.一位0-9都可以，多位不能是0（\d|([1-9]\d+))
        //3.小数部分可能有可能没有，一旦有后面必须有小点数+数字(\.\d+)?

        let reg =/^[10-29]$/
        console.log(reg.test("1"));//true
        console.log(reg.test("8"));//false
        console.log(reg.test("18"))//false

        reg = /^[10-29]$/
        console.log(reg.test("1"));//true
        console.log(reg.test("9"));//true
        console.log(reg.test("0"));//true
        console.log(reg.test("2"));//true
        console.log(reg.test("10"));//false

        let reg = /^[+-]?(\d|([1-9]\d+))(.\d+)?$/;

        //2.验证码
         //=>数字，字母，下划线
         //=>6-16位
         let val = userPassInp.value,
             reg = /^\w{6,16}$/;
         let flag = reg.test(val);

         function checkPass(val){
             if(val.length<6 || val.length>16){
                 alert("长度必须介于6-16位之间！");
                 return;
             }
             let area=['a','b'....'_'];
             //下划线
             for(let i=0;i<val.length;i++){
                 let char=val[i];
                 if(!area.includes(char)){
                     alert("格式不正确！");
                     return;
                 }
             }
         }
         //3.验证真实姓名
         //1.汉字 /^[\u4E00-\u9FA5]$/
         //2.名字长度 2-10位
         //3.可能有译名 .汉字(.[\u4E00-\u9FA5]{2,10}){0,2}

         let reg = /^[\u4E00-\u9FA5]{2,10}(.[\u4E00-\u9FA5]{2,10}){0,2}$/;

         //验证邮箱的
         let reg = /^\w+((-\w+)|(\.\w+))*@[A-za-z0-9]+((\.|-)[A-za-z0-9]+)*\.[A-za-z0-9]+$/;

         //1.开头是数字字母下划线(1到多位)
         //2.还可以是 -数字字母下划线 或者 .数字字母下划线，整体零到多次
         //=>邮箱的名字由"数字,字母，下划线，一,."几部分组成，但是-/.不能连续出现也不能作为开始

         //=>@[A-Za-z0-9]+)*
         //1.@后面紧跟着：数字，字母(1-多位)
         //=>((\.|-)[A-Za-z0-9]+)*
         //1.对@后面名字的补充
         //多域名  .com.cn
         //企业邮箱 zxt@zhufeng-peixun-office.com

         //=> \.[A-Za-z0-9]+
         //1.这个匹配的是最后的域名(.com/.cn/.org/.edu/.net...)

         //5.身份证号码
         let reg ="411523199507044556"
             str = /^(\d{6})(\d{4})(\d{2})(\d{2})(\d{2})(\d)(\d|x)$/;
         reg.exec("411523199507044556")

         //正则2种创建方式的区别
          let reg = /\d+/g;
              reg = new RegExp("\\d+","g");
         //=>正则表达是中的部分内容是变量存储的值
           //1.2个斜杠中间包起来的都是元字符(如果正则中要包含某个变量的值，则不能使用字面量方式创建)
           let type = "zhufeng";
           reg =/^@"+type+@"$/;
           console.log(reg.test("@zhufeng"))//false
           console.log(reg.test('@""typeeeee"@'))//true
           //2.这种情况只能使用构造函数方式(行为它传递的规则是字符串，只有这样才能进行字符串拼接)
           reg = new RegExp("^@"+type+"@$");
           console.log(reg.test("@zhufeng"))//false
           console.log(reg.test("@zhufeng@"))//true

           //实现正则捕获的方法
           //exec
           //test

           //字符串string.protype上支持正则表达式处理方式
            //replace
            //match
            //splice
            let str ="2019zhufeng2020yanfan2021qihang";
            let reg=/\d+/;

            /*
              基于exec实现正则捕获
              捕获到的结果是null或者一个数组
              第一项：本次捕获到的内容
              其余项：对应小分组本次单独捕获的内容
              index：当前捕获内容在字符串中的起始索引
              input：原始字符串

              2.每执行一次exec，只能捕获到一个符合正则规则的，但是默认情况下，我们执行一百遍，获取的结果永远都是第一个匹配到的，其余的捕获不到
                正则捕获的赖惰性：默认捕获第一个
            */
            console.log(reg.exec(str));//=>["2019",index:7,input:"2019zhufeng2020yangfang2021qihang"]
            console.log(reg.exec(str));//=>["2019"...]

            //=>实现正则捕获的前提是：当前正则要和字符串匹配，如果不匹配捕获的结果是null
            let reg = /^\d+$/;
            console.log(reg.test(str));//false
            console.log(reg.exec(str));//["2019"...]

            // 实现正则捕获的前提是：当前正则要和字符串匹配，如果不匹配捕获的结果null
            //  let reg = /^\d+$/;
            // console.log(reg.test(str));//false
            // console.log(reg.exec(str));//null

            //懒惰性的解决方法
            let str = "2019zhufeng2020yangfeng2021qihang"
            /*
            reg.lastIndex:当前正则下一次匹配的起始索引位置
            懒惰性捕获的原因：默认情况下lastIndex的值不会被修改，每一次都是从字符串开始位置查找，所以找到的永远只是第一个
            解决办法：全局修饰符g
            */

            let reg = /\d+/g;
            console.log(reg.lastIndex);//0 下面匹配捕获是从str索引零的位置开始找
            console.log(reg.exec(str));//=>["2019"...]
            console.log(reg.lastIndex);//=>11 设置全局匹配修饰符g后；
            //第一次匹配完,lastIndex会自己修改
            console.log(reg.exec(str))//["2019",index:7,input:"zhufeng2019yangfan2020qihang2021"]
            console.log(ret.exec(str));//["2019"...]

            /*
            //实现正则捕获的前提是：当前正则要和字符串匹配，如果不匹配捕获的结果是null

            let reg = /^\d+$/;
            console.log(reg.test(str));//false
            console.log(reg.exec(str));//null
            */
            ```()
            赖惰性的解决办法
            let str = "2019zhufeng2020yangfan2021qihang";
            reg.lastIdex:当前正则下一次匹配的起始索引位置
            懒惰性捕获的原因：默认情况下lastIdenx的值不会被修改，每一次都是从字符串开始查找位置，所以找到的永远只是第一个
              解决办法：全局修饰符g
              
              let reg = /\d+/;
              console.log(reg.lastIndex);//0 下面匹配捕获是从STR索引零的位置开始找
              console.log(reg.exec(str));
              console.log(reg.lastOIndex);//0 第一个匹配捕获完成，lastIndex没有改变，所以下一次exec依然是从字符串做开始找，找到的永远只是第一个匹配到的

              let reg = /\d+/g;
              console.log(reg.exec(str));=>["2019"...]
              console.log(reg.lastIndex);//11 设置全局匹配修饰符g后，第一次匹配完，lastIndex会自己修改
              
              //编写一个execAll方法
              ~ function(){
                  function execAll(str = ""){
                      //=>str:要匹配的字符串
                      //=>this:RegExp的实例(当前操作的正则)
                      //进来后的第一件事，是验证当前正则是否设置了G，不设置则不能在进行循环捕获了，否则会导致死循环
                      if（！this.global)return this.exec(str);
                      // ary存储最后所有捕获的信息 res存储每一次捕获的内容(数组)

                      let ary = [];
                           res = this.exec(str);
                           while(res){
                               ary.push(res[0]);
                               res = this.exec(str);
                           }
                           return ary.length === 0? null:ary;
                  }
                  RegExp.prototype.exexAll = execAll;
              }();

              let reg = /\d+/g;
              console.log("珠峰2019@2020培训".match(reg));

              //既要捕获到{数字},也想单独的把数字也获取到，例如第一次找到{0} 还需要单独获取0
              let str = "{0}年{1}月{2}日";

              不设置g只匹配一次，exec和match获取的结果一致(既有大正则匹配的信息，也有小分组匹配信息)
               let reg = /\{(\d+)\}/;
               console.log(reg.exec(str));
               console.log(str.match(reg));

               let reg = /\{(\d+)\}/g;
               console.log(str.mactch(reg));//["{0}","{1}","{2}"]

               let aryBig =[];
                   arySmall=[];
                   res=reg.exec(str);
                   while(res){
                       let [big,small] =res;
                       aryBig.push(big);
                       arySmall.push(small);
                       res = reg.exec(str);
                   }
                   console.log(aryBig,arySmall);

                    let str = "book";
                    let reg = /^[a-zA-Z]([a-zA-Z])\1[a-zA-Z]$/;
                    console.log(reg.test("book"));//true
                    console.log(reg.test("deep"));//true
                    console.log(reg.test("some"))//false

                    let str ="2019珠峰@2020培训";
                    //正则捕获的贪婪性：默认情况下，正则捕获的时候，是按照当前正则所匹配的最长结果来获取的
                    let reg = /\d+/g
                    console.log(str.mactch(reg))//["2019","2020"]
                    //在量词元字符后面设置？: 取消捕获时候的贪婪性(a按照正则匹配的最短结果来获取)

                    reg = /\d+?/g;
                    console.log(str.match(reg))//["2","0","1","9","2","0","2","0"]

                     //问号在正则中的五大作用：
                     问号左边是非量词元字符：本身代表量词元字符，出现零到一次
                     问号左边是量词元字符：取消捕获时候的贪婪性
                     (?:)只匹配不捕获
                     (?=) 正向预查
                     (?!) 负向预查

                     1.test也能捕获
                     let str = "{0}年{1}月{2}日";
                     let reg = /\{(\d+)\}/g;
                     console.log(reg.test(str));//true
                     console.log(RegExp.$1);//"0"

                     console.log(reg.test(str))//true
                     console.log(RegExp.$1)//"1"

                     把时间字符串进行处理
                     let time = "2019-08-13";
                     //=>变为"2019年08月13日"
                     let reg = /^(\d{4})-(\d{1,2})-(\d{1,2})$/;

                     //replace
                     time = time.replace(reg,"$1年$2月$3日");
                     console.log(time); //2019年08月13日

                     //还可以这样处理 [str].replace([reg],[function])
                     //1.首先拿reg和time进行匹配捕获，能匹配到几次就会把传递函数执行几次(而且是匹配一次就执行一次)
                     //2.不仅把方法执行,而且replace还给方法传递了实参信息(和exec捕获的内容一致信息)，大正则匹配的内容，小分组匹配的信息...)
                     //3.在函数中我们返回的是啥，就把当前大正则匹配的内容替换成啥

                     time = time.replace(reg,(big,$1,$2,$3)=>{
                         //这里的$1~$3是我们自己设置的变量
                         console.log(big,$1,$2,$3);
                     })

                     time = time.replace(reg,(...arg)=>{
                         let [,$1,$2,$3]=arg;
                         $2.length<2?$2="0"+$2:null;
                         $3.length<2？$3="0"+$3:null;
                         return $1+"年"+$2+"月"+$3+"日";
                     })

                     





            


    


        


    </script>
</body>
</html>